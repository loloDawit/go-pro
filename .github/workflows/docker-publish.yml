name: Build, Push Docker image to ECR, and Deploy to ECS

on:
  workflow_run:
    workflows: ["Go CI"]
    types:
      - completed

env:
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com
  ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
  IMAGE_TAG: ${{ github.sha }}

jobs:
  build-and-push:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Log in to Amazon ECR
        run: |
          aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}

      - name: Build Docker image with SHA tag
        run: |
          docker build \
            --build-arg DB_USER=${{ secrets.DB_USER }} \
            --build-arg DB_PASSWORD=${{ secrets.DB_PASSWORD }} \
            --build-arg DB_HOSTNAME=${{ secrets.DB_HOSTNAME }} \
            --build-arg DB_NAME=${{ secrets.DB_NAME }} \
            --build-arg JWT_SECRET=${{ secrets.JWT_SECRET }} \
            -t ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }} .

      - name: Tag Docker image as latest
        run: |
          docker tag ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }} ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:latest

      - name: Push Docker image with SHA tag
        run: |
          docker push ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}

      - name: Push Docker image with latest tag
        run: |
          docker push ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:latest

      - name: Get Image Digest
        id: image_digest
        run: |
          IMAGE_DIGEST=$(aws ecr describe-images --repository-name ${{ env.ECR_REPOSITORY }} --query 'imageDetails[?imageTags[?contains(@, `latest`)]].imageDigest' --output text)
          echo "digest=$IMAGE_DIGEST" >> $GITHUB_ENV

      - name: Register New Task Definition
        run: |
          TASK_DEFINITION=$(cat <<EOF
          {
            "family": "go-pro-app-task",
            "networkMode": "awsvpc",
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "256",
            "memory": "512",
            "executionRoleArn": "${{ secrets.EXECUTION_ROLE_ARN }}",
            "containerDefinitions": [
              {
                "name": "go_pro_app",
                "image": "$ECR_REGISTRY/$ECR_REPOSITORY@${{ env.digest }}",
                "essential": true,
                "portMappings": [
                  {
                    "containerPort": 8080,
                    "hostPort": 8080
                  }
                ],
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-group": "/ecs/go_pro_app",
                    "awslogs-region": "${{ secrets.AWS_REGION }}",
                    "awslogs-stream-prefix": "ecs"
                  }
                },
                "environment": [
                  {
                    "name": "DB_USER",
                    "value": "${{ secrets.DB_USER }}"
                  },
                  {
                    "name": "DB_PASSWORD",
                    "value": "${{ secrets.DB_PASSWORD }}"
                  },
                  {
                    "name": "DB_HOSTNAME",
                    "value": "${{ secrets.DB_HOSTNAME }}"
                  },
                  {
                    "name": "DB_NAME",
                    "value": "${{ secrets.DB_NAME }}"
                  },
                  {
                    "name": "JWT_SECRET",
                    "value": "${{ secrets.JWT_SECRET }}"
                  }
                ]
              }
            ]
          }
          EOF
          )

          echo "$TASK_DEFINITION" > new_task_definition.json

          aws ecs register-task-definition --cli-input-json file://new_task_definition.json

      # - name: Update ECS Service
      #   run: |
      #     NEW_TASK_DEFINITION_ARN=$(aws ecs describe-task-definition --task-definition go-pro-app-task --query 'taskDefinition.taskDefinitionArn' --output text)
      #     aws ecs update-service --cluster go-pro-app-cluster --service go-pro-app-service --task-definition $NEW_TASK_DEFINITION_ARN
      - name: Update ECS Service
        id: update_ecs
        run: |
            set -e
            NEW_TASK_DEFINITION_ARN=$(aws ecs describe-task-definition --task-definition go-pro-app-task --query 'taskDefinition.taskDefinitionArn' --output text)
            update_output=$(aws ecs update-service --cluster go-pro-app-cluster --service go-pro-app-service --task-definition $NEW_TASK_DEFINITION_ARN 2>&1) || update_status=$?
            echo "update_output=$update_output" >> $GITHUB_ENV
            if [ -z "$update_status" ]; then
              echo "service_update_status=success" >> $GITHUB_ENV
            else
              echo "service_update_status=failure" >> $GITHUB_ENV
              echo "update_status=$update_status" >> $GITHUB_ENV
            fi
        shell: bash
        
      - name: Check ECS Service Update Status
        if: ${{ env.service_update_status == 'success' }}
        run: echo "ECS Service update was successful."
        
      - name: Handle ECS Service Update Failure
        if: ${{ env.service_update_status == 'failure' }}
        run: |
            echo "ECS Service update failed with status ${{ env.update_status }}."
            echo "Error output:"
            echo "${{ env.update_output }}"
        
